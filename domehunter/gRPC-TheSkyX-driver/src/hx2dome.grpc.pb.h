// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: hx2dome.proto
// Original file comments:
// Protocol buffer interface for the TheSkyX X2 Dome interface,
// http://www.bisque.com/x2standard/class_x2_dome.html
#ifndef GRPC_hx2dome_2eproto__INCLUDED
#define GRPC_hx2dome_2eproto__INCLUDED

#include "hx2dome.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace hx2dome {

class HX2Dome final {
 public:
  static constexpr char const* service_full_name() {
    return "hx2dome.HX2Dome";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Dome API
    virtual ::grpc::Status dapiGetAzEl(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::AzEl* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::AzEl>> AsyncdapiGetAzEl(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::AzEl>>(AsyncdapiGetAzElRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::AzEl>> PrepareAsyncdapiGetAzEl(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::AzEl>>(PrepareAsyncdapiGetAzElRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiGotoAzEl(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::hx2dome::ReturnCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> AsyncdapiGotoAzEl(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(AsyncdapiGotoAzElRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> PrepareAsyncdapiGotoAzEl(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(PrepareAsyncdapiGotoAzElRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiAbort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> AsyncdapiAbort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(AsyncdapiAbortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> PrepareAsyncdapiAbort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(PrepareAsyncdapiAbortRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiOpen(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> AsyncdapiOpen(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(AsyncdapiOpenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> PrepareAsyncdapiOpen(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(PrepareAsyncdapiOpenRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiClose(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> AsyncdapiClose(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(AsyncdapiCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> PrepareAsyncdapiClose(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(PrepareAsyncdapiCloseRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiPark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> AsyncdapiPark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(AsyncdapiParkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> PrepareAsyncdapiPark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(PrepareAsyncdapiParkRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiUnpark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> AsyncdapiUnpark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(AsyncdapiUnparkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> PrepareAsyncdapiUnpark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(PrepareAsyncdapiUnparkRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiFindHome(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> AsyncdapiFindHome(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(AsyncdapiFindHomeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> PrepareAsyncdapiFindHome(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(PrepareAsyncdapiFindHomeRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiIsGotoComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> AsyncdapiIsGotoComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(AsyncdapiIsGotoCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> PrepareAsyncdapiIsGotoComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsGotoCompleteRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiIsOpenComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> AsyncdapiIsOpenComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(AsyncdapiIsOpenCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> PrepareAsyncdapiIsOpenComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsOpenCompleteRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiIsCloseComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> AsyncdapiIsCloseComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(AsyncdapiIsCloseCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> PrepareAsyncdapiIsCloseComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsCloseCompleteRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiIsParkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> AsyncdapiIsParkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(AsyncdapiIsParkCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> PrepareAsyncdapiIsParkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsParkCompleteRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiIsUnparkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> AsyncdapiIsUnparkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(AsyncdapiIsUnparkCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> PrepareAsyncdapiIsUnparkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsUnparkCompleteRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiIsFindHomeComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> AsyncdapiIsFindHomeComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(AsyncdapiIsFindHomeCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>> PrepareAsyncdapiIsFindHomeComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsFindHomeCompleteRaw(context, request, cq));
    }
    virtual ::grpc::Status dapiSync(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::hx2dome::ReturnCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> AsyncdapiSync(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(AsyncdapiSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>> PrepareAsyncdapiSync(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>>(PrepareAsyncdapiSyncRaw(context, request, cq));
    }
    // Hardware Info Interface
    virtual ::grpc::Status deviceInfoNameShort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> AsyncdeviceInfoNameShort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(AsyncdeviceInfoNameShortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoNameShort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoNameShortRaw(context, request, cq));
    }
    virtual ::grpc::Status deviceInfoNameLong(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> AsyncdeviceInfoNameLong(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(AsyncdeviceInfoNameLongRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoNameLong(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoNameLongRaw(context, request, cq));
    }
    virtual ::grpc::Status deviceInfoDetailedDescription(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> AsyncdeviceInfoDetailedDescription(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(AsyncdeviceInfoDetailedDescriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoDetailedDescription(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoDetailedDescriptionRaw(context, request, cq));
    }
    virtual ::grpc::Status deviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> AsyncdeviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(AsyncdeviceInfoFirmwareVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoFirmwareVersionRaw(context, request, cq));
    }
    virtual ::grpc::Status deviceInfoModel(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> AsyncdeviceInfoModel(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(AsyncdeviceInfoModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoModel(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoModelRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Dome API
      virtual void dapiGetAzEl(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiGetAzEl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::AzEl* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiGotoAzEl(::grpc::ClientContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiGotoAzEl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiAbort(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiAbort(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiOpen(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiOpen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiClose(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiClose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiPark(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiPark(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiUnpark(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiUnpark(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiFindHome(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiFindHome(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsGotoComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsGotoComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsOpenComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsOpenComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsCloseComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsCloseComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsParkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsParkComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsUnparkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsUnparkComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsFindHomeComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiIsFindHomeComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiSync(::grpc::ClientContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void dapiSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) = 0;
      // Hardware Info Interface
      virtual void deviceInfoNameShort(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoNameShort(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoNameLong(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoNameLong(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoDetailedDescription(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoDetailedDescription(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoModel(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
      virtual void deviceInfoModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::AzEl>* AsyncdapiGetAzElRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::AzEl>* PrepareAsyncdapiGetAzElRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* AsyncdapiGotoAzElRaw(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* PrepareAsyncdapiGotoAzElRaw(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* AsyncdapiAbortRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* PrepareAsyncdapiAbortRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* AsyncdapiOpenRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* PrepareAsyncdapiOpenRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* AsyncdapiCloseRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* PrepareAsyncdapiCloseRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* AsyncdapiParkRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* PrepareAsyncdapiParkRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* AsyncdapiUnparkRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* PrepareAsyncdapiUnparkRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* AsyncdapiFindHomeRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* PrepareAsyncdapiFindHomeRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* AsyncdapiIsGotoCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* PrepareAsyncdapiIsGotoCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* AsyncdapiIsOpenCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* PrepareAsyncdapiIsOpenCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* AsyncdapiIsCloseCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* PrepareAsyncdapiIsCloseCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* AsyncdapiIsParkCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* PrepareAsyncdapiIsParkCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* AsyncdapiIsUnparkCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* PrepareAsyncdapiIsUnparkCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* AsyncdapiIsFindHomeCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::IsComplete>* PrepareAsyncdapiIsFindHomeCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* AsyncdapiSyncRaw(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::ReturnCode>* PrepareAsyncdapiSyncRaw(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* AsyncdeviceInfoNameShortRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoNameShortRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* AsyncdeviceInfoNameLongRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoNameLongRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* AsyncdeviceInfoDetailedDescriptionRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoDetailedDescriptionRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* AsyncdeviceInfoFirmwareVersionRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoFirmwareVersionRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* AsyncdeviceInfoModelRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoModelRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status dapiGetAzEl(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::AzEl* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::AzEl>> AsyncdapiGetAzEl(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::AzEl>>(AsyncdapiGetAzElRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::AzEl>> PrepareAsyncdapiGetAzEl(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::AzEl>>(PrepareAsyncdapiGetAzElRaw(context, request, cq));
    }
    ::grpc::Status dapiGotoAzEl(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::hx2dome::ReturnCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> AsyncdapiGotoAzEl(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(AsyncdapiGotoAzElRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> PrepareAsyncdapiGotoAzEl(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(PrepareAsyncdapiGotoAzElRaw(context, request, cq));
    }
    ::grpc::Status dapiAbort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> AsyncdapiAbort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(AsyncdapiAbortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> PrepareAsyncdapiAbort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(PrepareAsyncdapiAbortRaw(context, request, cq));
    }
    ::grpc::Status dapiOpen(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> AsyncdapiOpen(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(AsyncdapiOpenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> PrepareAsyncdapiOpen(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(PrepareAsyncdapiOpenRaw(context, request, cq));
    }
    ::grpc::Status dapiClose(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> AsyncdapiClose(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(AsyncdapiCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> PrepareAsyncdapiClose(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(PrepareAsyncdapiCloseRaw(context, request, cq));
    }
    ::grpc::Status dapiPark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> AsyncdapiPark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(AsyncdapiParkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> PrepareAsyncdapiPark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(PrepareAsyncdapiParkRaw(context, request, cq));
    }
    ::grpc::Status dapiUnpark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> AsyncdapiUnpark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(AsyncdapiUnparkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> PrepareAsyncdapiUnpark(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(PrepareAsyncdapiUnparkRaw(context, request, cq));
    }
    ::grpc::Status dapiFindHome(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::ReturnCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> AsyncdapiFindHome(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(AsyncdapiFindHomeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> PrepareAsyncdapiFindHome(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(PrepareAsyncdapiFindHomeRaw(context, request, cq));
    }
    ::grpc::Status dapiIsGotoComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> AsyncdapiIsGotoComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(AsyncdapiIsGotoCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> PrepareAsyncdapiIsGotoComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsGotoCompleteRaw(context, request, cq));
    }
    ::grpc::Status dapiIsOpenComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> AsyncdapiIsOpenComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(AsyncdapiIsOpenCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> PrepareAsyncdapiIsOpenComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsOpenCompleteRaw(context, request, cq));
    }
    ::grpc::Status dapiIsCloseComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> AsyncdapiIsCloseComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(AsyncdapiIsCloseCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> PrepareAsyncdapiIsCloseComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsCloseCompleteRaw(context, request, cq));
    }
    ::grpc::Status dapiIsParkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> AsyncdapiIsParkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(AsyncdapiIsParkCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> PrepareAsyncdapiIsParkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsParkCompleteRaw(context, request, cq));
    }
    ::grpc::Status dapiIsUnparkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> AsyncdapiIsUnparkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(AsyncdapiIsUnparkCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> PrepareAsyncdapiIsUnparkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsUnparkCompleteRaw(context, request, cq));
    }
    ::grpc::Status dapiIsFindHomeComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::IsComplete* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> AsyncdapiIsFindHomeComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(AsyncdapiIsFindHomeCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>> PrepareAsyncdapiIsFindHomeComplete(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>>(PrepareAsyncdapiIsFindHomeCompleteRaw(context, request, cq));
    }
    ::grpc::Status dapiSync(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::hx2dome::ReturnCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> AsyncdapiSync(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(AsyncdapiSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>> PrepareAsyncdapiSync(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>>(PrepareAsyncdapiSyncRaw(context, request, cq));
    }
    ::grpc::Status deviceInfoNameShort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> AsyncdeviceInfoNameShort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(AsyncdeviceInfoNameShortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoNameShort(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoNameShortRaw(context, request, cq));
    }
    ::grpc::Status deviceInfoNameLong(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> AsyncdeviceInfoNameLong(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(AsyncdeviceInfoNameLongRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoNameLong(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoNameLongRaw(context, request, cq));
    }
    ::grpc::Status deviceInfoDetailedDescription(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> AsyncdeviceInfoDetailedDescription(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(AsyncdeviceInfoDetailedDescriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoDetailedDescription(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoDetailedDescriptionRaw(context, request, cq));
    }
    ::grpc::Status deviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> AsyncdeviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(AsyncdeviceInfoFirmwareVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoFirmwareVersionRaw(context, request, cq));
    }
    ::grpc::Status deviceInfoModel(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::hx2dome::BasicString* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> AsyncdeviceInfoModel(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(AsyncdeviceInfoModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>> PrepareAsyncdeviceInfoModel(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>>(PrepareAsyncdeviceInfoModelRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void dapiGetAzEl(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response, std::function<void(::grpc::Status)>) override;
      void dapiGetAzEl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::AzEl* response, std::function<void(::grpc::Status)>) override;
      void dapiGotoAzEl(::grpc::ClientContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiGotoAzEl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiAbort(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiAbort(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiOpen(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiOpen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiClose(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiClose(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiPark(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiPark(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiUnpark(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiUnpark(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiFindHome(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiFindHome(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiIsGotoComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsGotoComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsOpenComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsOpenComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsCloseComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsCloseComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsParkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsParkComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsUnparkComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsUnparkComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsFindHomeComplete(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiIsFindHomeComplete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::IsComplete* response, std::function<void(::grpc::Status)>) override;
      void dapiSync(::grpc::ClientContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void dapiSync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::ReturnCode* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoNameShort(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoNameShort(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoNameLong(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoNameLong(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoDetailedDescription(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoDetailedDescription(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoFirmwareVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoModel(::grpc::ClientContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
      void deviceInfoModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::hx2dome::BasicString* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::hx2dome::AzEl>* AsyncdapiGetAzElRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::AzEl>* PrepareAsyncdapiGetAzElRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* AsyncdapiGotoAzElRaw(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* PrepareAsyncdapiGotoAzElRaw(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* AsyncdapiAbortRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* PrepareAsyncdapiAbortRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* AsyncdapiOpenRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* PrepareAsyncdapiOpenRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* AsyncdapiCloseRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* PrepareAsyncdapiCloseRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* AsyncdapiParkRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* PrepareAsyncdapiParkRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* AsyncdapiUnparkRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* PrepareAsyncdapiUnparkRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* AsyncdapiFindHomeRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* PrepareAsyncdapiFindHomeRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* AsyncdapiIsGotoCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* PrepareAsyncdapiIsGotoCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* AsyncdapiIsOpenCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* PrepareAsyncdapiIsOpenCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* AsyncdapiIsCloseCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* PrepareAsyncdapiIsCloseCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* AsyncdapiIsParkCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* PrepareAsyncdapiIsParkCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* AsyncdapiIsUnparkCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* PrepareAsyncdapiIsUnparkCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* AsyncdapiIsFindHomeCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::IsComplete>* PrepareAsyncdapiIsFindHomeCompleteRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* AsyncdapiSyncRaw(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::ReturnCode>* PrepareAsyncdapiSyncRaw(::grpc::ClientContext* context, const ::hx2dome::AzEl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* AsyncdeviceInfoNameShortRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoNameShortRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* AsyncdeviceInfoNameLongRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoNameLongRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* AsyncdeviceInfoDetailedDescriptionRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoDetailedDescriptionRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* AsyncdeviceInfoFirmwareVersionRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoFirmwareVersionRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* AsyncdeviceInfoModelRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hx2dome::BasicString>* PrepareAsyncdeviceInfoModelRaw(::grpc::ClientContext* context, const ::hx2dome::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_dapiGetAzEl_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiGotoAzEl_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiAbort_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiOpen_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiClose_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiPark_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiUnpark_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiFindHome_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiIsGotoComplete_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiIsOpenComplete_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiIsCloseComplete_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiIsParkComplete_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiIsUnparkComplete_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiIsFindHomeComplete_;
    const ::grpc::internal::RpcMethod rpcmethod_dapiSync_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceInfoNameShort_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceInfoNameLong_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceInfoDetailedDescription_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceInfoFirmwareVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_deviceInfoModel_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Dome API
    virtual ::grpc::Status dapiGetAzEl(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response);
    virtual ::grpc::Status dapiGotoAzEl(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response);
    virtual ::grpc::Status dapiAbort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response);
    virtual ::grpc::Status dapiOpen(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response);
    virtual ::grpc::Status dapiClose(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response);
    virtual ::grpc::Status dapiPark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response);
    virtual ::grpc::Status dapiUnpark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response);
    virtual ::grpc::Status dapiFindHome(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response);
    virtual ::grpc::Status dapiIsGotoComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response);
    virtual ::grpc::Status dapiIsOpenComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response);
    virtual ::grpc::Status dapiIsCloseComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response);
    virtual ::grpc::Status dapiIsParkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response);
    virtual ::grpc::Status dapiIsUnparkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response);
    virtual ::grpc::Status dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response);
    virtual ::grpc::Status dapiSync(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response);
    // Hardware Info Interface
    virtual ::grpc::Status deviceInfoNameShort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response);
    virtual ::grpc::Status deviceInfoNameLong(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response);
    virtual ::grpc::Status deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response);
    virtual ::grpc::Status deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response);
    virtual ::grpc::Status deviceInfoModel(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiGetAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiGetAzEl() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_dapiGetAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGetAzEl(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiGetAzEl(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::AzEl>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiGotoAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiGotoAzEl() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_dapiGotoAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGotoAzEl(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiGotoAzEl(::grpc::ServerContext* context, ::hx2dome::AzEl* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::ReturnCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiAbort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiAbort() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_dapiAbort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiAbort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiAbort(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::ReturnCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiOpen() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_dapiOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiOpen(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiOpen(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::ReturnCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiClose() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_dapiClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiClose(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiClose(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::ReturnCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiPark() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_dapiPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiPark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiPark(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::ReturnCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiUnpark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiUnpark() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_dapiUnpark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiUnpark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiUnpark(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::ReturnCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiFindHome : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiFindHome() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_dapiFindHome() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiFindHome(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiFindHome(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::ReturnCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiIsGotoComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiIsGotoComplete() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_dapiIsGotoComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsGotoComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsGotoComplete(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::IsComplete>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiIsOpenComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiIsOpenComplete() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_dapiIsOpenComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsOpenComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsOpenComplete(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::IsComplete>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiIsCloseComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiIsCloseComplete() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_dapiIsCloseComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsCloseComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsCloseComplete(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::IsComplete>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiIsParkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiIsParkComplete() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_dapiIsParkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsParkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsParkComplete(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::IsComplete>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiIsUnparkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiIsUnparkComplete() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_dapiIsUnparkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsUnparkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsUnparkComplete(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::IsComplete>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiIsFindHomeComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiIsFindHomeComplete() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_dapiIsFindHomeComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsFindHomeComplete(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::IsComplete>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_dapiSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_dapiSync() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_dapiSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiSync(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiSync(::grpc::ServerContext* context, ::hx2dome::AzEl* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::ReturnCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceInfoNameShort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_deviceInfoNameShort() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_deviceInfoNameShort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameShort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoNameShort(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::BasicString>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceInfoNameLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_deviceInfoNameLong() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_deviceInfoNameLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameLong(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoNameLong(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::BasicString>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceInfoDetailedDescription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_deviceInfoDetailedDescription() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_deviceInfoDetailedDescription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoDetailedDescription(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::BasicString>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceInfoFirmwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_deviceInfoFirmwareVersion() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_deviceInfoFirmwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoFirmwareVersion(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::BasicString>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_deviceInfoModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_deviceInfoModel() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_deviceInfoModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoModel(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoModel(::grpc::ServerContext* context, ::hx2dome::Empty* request, ::grpc::ServerAsyncResponseWriter< ::hx2dome::BasicString>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_dapiGetAzEl<WithAsyncMethod_dapiGotoAzEl<WithAsyncMethod_dapiAbort<WithAsyncMethod_dapiOpen<WithAsyncMethod_dapiClose<WithAsyncMethod_dapiPark<WithAsyncMethod_dapiUnpark<WithAsyncMethod_dapiFindHome<WithAsyncMethod_dapiIsGotoComplete<WithAsyncMethod_dapiIsOpenComplete<WithAsyncMethod_dapiIsCloseComplete<WithAsyncMethod_dapiIsParkComplete<WithAsyncMethod_dapiIsUnparkComplete<WithAsyncMethod_dapiIsFindHomeComplete<WithAsyncMethod_dapiSync<WithAsyncMethod_deviceInfoNameShort<WithAsyncMethod_deviceInfoNameLong<WithAsyncMethod_deviceInfoDetailedDescription<WithAsyncMethod_deviceInfoFirmwareVersion<WithAsyncMethod_deviceInfoModel<Service > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiGetAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiGetAzEl() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::AzEl>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::AzEl* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiGetAzEl(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiGetAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGetAzEl(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiGetAzEl(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiGotoAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiGotoAzEl() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::AzEl, ::hx2dome::ReturnCode>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::AzEl* request,
                 ::hx2dome::ReturnCode* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiGotoAzEl(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiGotoAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGotoAzEl(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiGotoAzEl(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiAbort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiAbort() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::ReturnCode* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiAbort(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiAbort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiAbort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiAbort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiOpen() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::ReturnCode* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiOpen(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiOpen(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiOpen(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiClose() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::ReturnCode* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiClose(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiClose(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiClose(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiPark() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::ReturnCode* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiPark(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiPark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiPark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiUnpark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiUnpark() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::ReturnCode* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiUnpark(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiUnpark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiUnpark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiUnpark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiFindHome : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiFindHome() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::ReturnCode* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiFindHome(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiFindHome() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiFindHome(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiFindHome(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiIsGotoComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiIsGotoComplete() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::IsComplete* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiIsGotoComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiIsGotoComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsGotoComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsGotoComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiIsOpenComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiIsOpenComplete() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::IsComplete* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiIsOpenComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiIsOpenComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsOpenComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsOpenComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiIsCloseComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiIsCloseComplete() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::IsComplete* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiIsCloseComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiIsCloseComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsCloseComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsCloseComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiIsParkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiIsParkComplete() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::IsComplete* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiIsParkComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiIsParkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsParkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsParkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiIsUnparkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiIsUnparkComplete() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::IsComplete* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiIsUnparkComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiIsUnparkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsUnparkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsUnparkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiIsFindHomeComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiIsFindHomeComplete() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::IsComplete* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiIsFindHomeComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiIsFindHomeComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_dapiSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_dapiSync() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::AzEl, ::hx2dome::ReturnCode>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::AzEl* request,
                 ::hx2dome::ReturnCode* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->dapiSync(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_dapiSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiSync(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiSync(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_deviceInfoNameShort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_deviceInfoNameShort() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::BasicString* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->deviceInfoNameShort(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_deviceInfoNameShort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameShort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoNameShort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_deviceInfoNameLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_deviceInfoNameLong() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::BasicString* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->deviceInfoNameLong(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_deviceInfoNameLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameLong(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoNameLong(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_deviceInfoDetailedDescription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_deviceInfoDetailedDescription() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::BasicString* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->deviceInfoDetailedDescription(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_deviceInfoDetailedDescription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_deviceInfoFirmwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_deviceInfoFirmwareVersion() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::BasicString* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->deviceInfoFirmwareVersion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_deviceInfoFirmwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_deviceInfoModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_deviceInfoModel() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(
          [this](::grpc::ServerContext* context,
                 const ::hx2dome::Empty* request,
                 ::hx2dome::BasicString* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->deviceInfoModel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_deviceInfoModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoModel(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoModel(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_dapiGetAzEl<ExperimentalWithCallbackMethod_dapiGotoAzEl<ExperimentalWithCallbackMethod_dapiAbort<ExperimentalWithCallbackMethod_dapiOpen<ExperimentalWithCallbackMethod_dapiClose<ExperimentalWithCallbackMethod_dapiPark<ExperimentalWithCallbackMethod_dapiUnpark<ExperimentalWithCallbackMethod_dapiFindHome<ExperimentalWithCallbackMethod_dapiIsGotoComplete<ExperimentalWithCallbackMethod_dapiIsOpenComplete<ExperimentalWithCallbackMethod_dapiIsCloseComplete<ExperimentalWithCallbackMethod_dapiIsParkComplete<ExperimentalWithCallbackMethod_dapiIsUnparkComplete<ExperimentalWithCallbackMethod_dapiIsFindHomeComplete<ExperimentalWithCallbackMethod_dapiSync<ExperimentalWithCallbackMethod_deviceInfoNameShort<ExperimentalWithCallbackMethod_deviceInfoNameLong<ExperimentalWithCallbackMethod_deviceInfoDetailedDescription<ExperimentalWithCallbackMethod_deviceInfoFirmwareVersion<ExperimentalWithCallbackMethod_deviceInfoModel<Service > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_dapiGetAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiGetAzEl() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_dapiGetAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGetAzEl(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiGotoAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiGotoAzEl() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_dapiGotoAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGotoAzEl(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiAbort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiAbort() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_dapiAbort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiAbort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiOpen() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_dapiOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiOpen(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiClose() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_dapiClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiClose(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiPark() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_dapiPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiPark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiUnpark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiUnpark() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_dapiUnpark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiUnpark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiFindHome : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiFindHome() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_dapiFindHome() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiFindHome(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiIsGotoComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiIsGotoComplete() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_dapiIsGotoComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsGotoComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiIsOpenComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiIsOpenComplete() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_dapiIsOpenComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsOpenComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiIsCloseComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiIsCloseComplete() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_dapiIsCloseComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsCloseComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiIsParkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiIsParkComplete() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_dapiIsParkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsParkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiIsUnparkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiIsUnparkComplete() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_dapiIsUnparkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsUnparkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiIsFindHomeComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiIsFindHomeComplete() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_dapiIsFindHomeComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_dapiSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_dapiSync() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_dapiSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiSync(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceInfoNameShort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_deviceInfoNameShort() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_deviceInfoNameShort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameShort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceInfoNameLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_deviceInfoNameLong() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_deviceInfoNameLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameLong(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceInfoDetailedDescription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_deviceInfoDetailedDescription() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_deviceInfoDetailedDescription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceInfoFirmwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_deviceInfoFirmwareVersion() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_deviceInfoFirmwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_deviceInfoModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_deviceInfoModel() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_deviceInfoModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoModel(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiGetAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiGetAzEl() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_dapiGetAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGetAzEl(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiGetAzEl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiGotoAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiGotoAzEl() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_dapiGotoAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGotoAzEl(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiGotoAzEl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiAbort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiAbort() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_dapiAbort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiAbort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiAbort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiOpen() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_dapiOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiOpen(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiOpen(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiClose() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_dapiClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiClose(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiClose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiPark() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_dapiPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiPark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiPark(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiUnpark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiUnpark() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_dapiUnpark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiUnpark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiUnpark(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiFindHome : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiFindHome() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_dapiFindHome() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiFindHome(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiFindHome(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiIsGotoComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiIsGotoComplete() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_dapiIsGotoComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsGotoComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsGotoComplete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiIsOpenComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiIsOpenComplete() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_dapiIsOpenComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsOpenComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsOpenComplete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiIsCloseComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiIsCloseComplete() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_dapiIsCloseComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsCloseComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsCloseComplete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiIsParkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiIsParkComplete() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_dapiIsParkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsParkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsParkComplete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiIsUnparkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiIsUnparkComplete() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_dapiIsUnparkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsUnparkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsUnparkComplete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiIsFindHomeComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiIsFindHomeComplete() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_dapiIsFindHomeComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiIsFindHomeComplete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_dapiSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_dapiSync() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_dapiSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiSync(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdapiSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceInfoNameShort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_deviceInfoNameShort() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_deviceInfoNameShort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameShort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoNameShort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceInfoNameLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_deviceInfoNameLong() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_deviceInfoNameLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameLong(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoNameLong(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceInfoDetailedDescription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_deviceInfoDetailedDescription() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_deviceInfoDetailedDescription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoDetailedDescription(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceInfoFirmwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_deviceInfoFirmwareVersion() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_deviceInfoFirmwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoFirmwareVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_deviceInfoModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_deviceInfoModel() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_deviceInfoModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoModel(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdeviceInfoModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiGetAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiGetAzEl() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiGetAzEl(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiGetAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGetAzEl(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiGetAzEl(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiGotoAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiGotoAzEl() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiGotoAzEl(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiGotoAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiGotoAzEl(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiGotoAzEl(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiAbort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiAbort() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiAbort(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiAbort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiAbort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiAbort(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiOpen() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiOpen(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiOpen(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiOpen(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiClose() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiClose(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiClose(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiClose(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiPark() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiPark(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiPark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiPark(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiUnpark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiUnpark() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiUnpark(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiUnpark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiUnpark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiUnpark(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiFindHome : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiFindHome() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiFindHome(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiFindHome() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiFindHome(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiFindHome(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiIsGotoComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiIsGotoComplete() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiIsGotoComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiIsGotoComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsGotoComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsGotoComplete(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiIsOpenComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiIsOpenComplete() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiIsOpenComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiIsOpenComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsOpenComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsOpenComplete(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiIsCloseComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiIsCloseComplete() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiIsCloseComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiIsCloseComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsCloseComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsCloseComplete(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiIsParkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiIsParkComplete() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiIsParkComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiIsParkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsParkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsParkComplete(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiIsUnparkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiIsUnparkComplete() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiIsUnparkComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiIsUnparkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsUnparkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsUnparkComplete(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiIsFindHomeComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiIsFindHomeComplete() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiIsFindHomeComplete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiIsFindHomeComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_dapiSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_dapiSync() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->dapiSync(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_dapiSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status dapiSync(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void dapiSync(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_deviceInfoNameShort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_deviceInfoNameShort() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->deviceInfoNameShort(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_deviceInfoNameShort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameShort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoNameShort(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_deviceInfoNameLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_deviceInfoNameLong() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->deviceInfoNameLong(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_deviceInfoNameLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoNameLong(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoNameLong(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_deviceInfoDetailedDescription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_deviceInfoDetailedDescription() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->deviceInfoDetailedDescription(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_deviceInfoDetailedDescription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_deviceInfoFirmwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_deviceInfoFirmwareVersion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->deviceInfoFirmwareVersion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_deviceInfoFirmwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_deviceInfoModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_deviceInfoModel() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->deviceInfoModel(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_deviceInfoModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status deviceInfoModel(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void deviceInfoModel(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiGetAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiGetAzEl() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::AzEl>(std::bind(&WithStreamedUnaryMethod_dapiGetAzEl<BaseClass>::StreameddapiGetAzEl, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiGetAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiGetAzEl(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::AzEl* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiGetAzEl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::AzEl>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiGotoAzEl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiGotoAzEl() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::AzEl, ::hx2dome::ReturnCode>(std::bind(&WithStreamedUnaryMethod_dapiGotoAzEl<BaseClass>::StreameddapiGotoAzEl, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiGotoAzEl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiGotoAzEl(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiGotoAzEl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::AzEl,::hx2dome::ReturnCode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiAbort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiAbort() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(std::bind(&WithStreamedUnaryMethod_dapiAbort<BaseClass>::StreameddapiAbort, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiAbort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiAbort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiAbort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::ReturnCode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiOpen() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(std::bind(&WithStreamedUnaryMethod_dapiOpen<BaseClass>::StreameddapiOpen, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiOpen(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiOpen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::ReturnCode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiClose() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(std::bind(&WithStreamedUnaryMethod_dapiClose<BaseClass>::StreameddapiClose, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiClose(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiClose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::ReturnCode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiPark() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(std::bind(&WithStreamedUnaryMethod_dapiPark<BaseClass>::StreameddapiPark, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiPark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiPark(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::ReturnCode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiUnpark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiUnpark() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(std::bind(&WithStreamedUnaryMethod_dapiUnpark<BaseClass>::StreameddapiUnpark, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiUnpark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiUnpark(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiUnpark(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::ReturnCode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiFindHome : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiFindHome() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::ReturnCode>(std::bind(&WithStreamedUnaryMethod_dapiFindHome<BaseClass>::StreameddapiFindHome, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiFindHome() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiFindHome(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiFindHome(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::ReturnCode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiIsGotoComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiIsGotoComplete() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(std::bind(&WithStreamedUnaryMethod_dapiIsGotoComplete<BaseClass>::StreameddapiIsGotoComplete, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiIsGotoComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiIsGotoComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiIsGotoComplete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::IsComplete>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiIsOpenComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiIsOpenComplete() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(std::bind(&WithStreamedUnaryMethod_dapiIsOpenComplete<BaseClass>::StreameddapiIsOpenComplete, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiIsOpenComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiIsOpenComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiIsOpenComplete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::IsComplete>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiIsCloseComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiIsCloseComplete() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(std::bind(&WithStreamedUnaryMethod_dapiIsCloseComplete<BaseClass>::StreameddapiIsCloseComplete, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiIsCloseComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiIsCloseComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiIsCloseComplete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::IsComplete>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiIsParkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiIsParkComplete() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(std::bind(&WithStreamedUnaryMethod_dapiIsParkComplete<BaseClass>::StreameddapiIsParkComplete, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiIsParkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiIsParkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiIsParkComplete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::IsComplete>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiIsUnparkComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiIsUnparkComplete() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(std::bind(&WithStreamedUnaryMethod_dapiIsUnparkComplete<BaseClass>::StreameddapiIsUnparkComplete, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiIsUnparkComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiIsUnparkComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiIsUnparkComplete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::IsComplete>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiIsFindHomeComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiIsFindHomeComplete() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::IsComplete>(std::bind(&WithStreamedUnaryMethod_dapiIsFindHomeComplete<BaseClass>::StreameddapiIsFindHomeComplete, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiIsFindHomeComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiIsFindHomeComplete(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::IsComplete* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiIsFindHomeComplete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::IsComplete>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_dapiSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_dapiSync() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::AzEl, ::hx2dome::ReturnCode>(std::bind(&WithStreamedUnaryMethod_dapiSync<BaseClass>::StreameddapiSync, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_dapiSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status dapiSync(::grpc::ServerContext* context, const ::hx2dome::AzEl* request, ::hx2dome::ReturnCode* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddapiSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::AzEl,::hx2dome::ReturnCode>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceInfoNameShort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_deviceInfoNameShort() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(std::bind(&WithStreamedUnaryMethod_deviceInfoNameShort<BaseClass>::StreameddeviceInfoNameShort, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_deviceInfoNameShort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceInfoNameShort(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceInfoNameShort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::BasicString>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceInfoNameLong : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_deviceInfoNameLong() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(std::bind(&WithStreamedUnaryMethod_deviceInfoNameLong<BaseClass>::StreameddeviceInfoNameLong, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_deviceInfoNameLong() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceInfoNameLong(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceInfoNameLong(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::BasicString>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceInfoDetailedDescription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_deviceInfoDetailedDescription() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(std::bind(&WithStreamedUnaryMethod_deviceInfoDetailedDescription<BaseClass>::StreameddeviceInfoDetailedDescription, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_deviceInfoDetailedDescription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceInfoDetailedDescription(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceInfoDetailedDescription(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::BasicString>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceInfoFirmwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_deviceInfoFirmwareVersion() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(std::bind(&WithStreamedUnaryMethod_deviceInfoFirmwareVersion<BaseClass>::StreameddeviceInfoFirmwareVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_deviceInfoFirmwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceInfoFirmwareVersion(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceInfoFirmwareVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::BasicString>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_deviceInfoModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_deviceInfoModel() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::hx2dome::Empty, ::hx2dome::BasicString>(std::bind(&WithStreamedUnaryMethod_deviceInfoModel<BaseClass>::StreameddeviceInfoModel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_deviceInfoModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status deviceInfoModel(::grpc::ServerContext* context, const ::hx2dome::Empty* request, ::hx2dome::BasicString* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddeviceInfoModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hx2dome::Empty,::hx2dome::BasicString>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_dapiGetAzEl<WithStreamedUnaryMethod_dapiGotoAzEl<WithStreamedUnaryMethod_dapiAbort<WithStreamedUnaryMethod_dapiOpen<WithStreamedUnaryMethod_dapiClose<WithStreamedUnaryMethod_dapiPark<WithStreamedUnaryMethod_dapiUnpark<WithStreamedUnaryMethod_dapiFindHome<WithStreamedUnaryMethod_dapiIsGotoComplete<WithStreamedUnaryMethod_dapiIsOpenComplete<WithStreamedUnaryMethod_dapiIsCloseComplete<WithStreamedUnaryMethod_dapiIsParkComplete<WithStreamedUnaryMethod_dapiIsUnparkComplete<WithStreamedUnaryMethod_dapiIsFindHomeComplete<WithStreamedUnaryMethod_dapiSync<WithStreamedUnaryMethod_deviceInfoNameShort<WithStreamedUnaryMethod_deviceInfoNameLong<WithStreamedUnaryMethod_deviceInfoDetailedDescription<WithStreamedUnaryMethod_deviceInfoFirmwareVersion<WithStreamedUnaryMethod_deviceInfoModel<Service > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_dapiGetAzEl<WithStreamedUnaryMethod_dapiGotoAzEl<WithStreamedUnaryMethod_dapiAbort<WithStreamedUnaryMethod_dapiOpen<WithStreamedUnaryMethod_dapiClose<WithStreamedUnaryMethod_dapiPark<WithStreamedUnaryMethod_dapiUnpark<WithStreamedUnaryMethod_dapiFindHome<WithStreamedUnaryMethod_dapiIsGotoComplete<WithStreamedUnaryMethod_dapiIsOpenComplete<WithStreamedUnaryMethod_dapiIsCloseComplete<WithStreamedUnaryMethod_dapiIsParkComplete<WithStreamedUnaryMethod_dapiIsUnparkComplete<WithStreamedUnaryMethod_dapiIsFindHomeComplete<WithStreamedUnaryMethod_dapiSync<WithStreamedUnaryMethod_deviceInfoNameShort<WithStreamedUnaryMethod_deviceInfoNameLong<WithStreamedUnaryMethod_deviceInfoDetailedDescription<WithStreamedUnaryMethod_deviceInfoFirmwareVersion<WithStreamedUnaryMethod_deviceInfoModel<Service > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace hx2dome


#endif  // GRPC_hx2dome_2eproto__INCLUDED
